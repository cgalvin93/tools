#parses every pdb file in working directory
#intended to be run in 'contact_pdbs' directory generated by 'contact_pdb.py'
#returns statistics about the contacts
#1. amino acid distribution of contact residues
#2. fraction of contacts for each ligand atom
#time ipython ~/desktop/tools/contact_stats.py PMP.params PMP
'''
intra structure redundancy is handled by only finding contact residues for one copy of the
ligand in the pdb file
'''

'''
OKAY THIS IS WORKING AS INTENDED, HOWEVER THE LIG ATOM FREQUENCIES ARE FUCKED UP
DUE TO INCONSISTENCIES IN ATOM NAMING OF THE LIGAND
MY QUICK FIX RIGHT NOW IS JUST GOING TO BE TO SHOW ONLY THE TOP 20 MOST
FREQUENTLY RECORDED LIG ATOM NAMES

BUT MAYBE THERE IS SOME WAY THAT I CAN EITHER MAKE THEM UNIFORM OR
TIE THE DIFFERENT NAMES BACK TO THEIR POSITION IN STRC OR SOMETHING?
if they are at least in the same order, then i can replace them all with
names from a pdb file generated along with params, but with coordinateds of
the original atoms
        just kidding im stupid and I didnt make sure all the hetatm lines
        were pmp so I had fucked up ligands
        now they are all the same
            std now anyway with params

!!!!!!!!!!!!!!!!!!!!!!!
NUMBER OF CONTACTS ON Average!
!!!!!!!!!!!!!!!!!!!!!

CAN ALSO MAYBE DO SOMETHING LIKE CLUSTERING, THAT WAY I CAN JUST LOOK AT THE
MOST FREQUENT KINDS OF CONTACTS AND SEE VISUALLY WHERE THEY TOUCH THE LIGAND

--------------------------------------------------------------------------------

alright so how can i make this useful?
1.aa dist:
    take out gly,pro,ala,cys



2. number of contacting residues
    higher than I thought it would be, thats really interesting
        HOW MANY HAVE NEGATIVE REU
NEW METRIC-NUMBER OF LIG ATOMS WITHOUT CONTACT
    shit but this doesnt capture cases where atoms contacted from multiple sides
N PTN ATOMS CONTACTING LIGAND / N LIGAND ATOMS
    this is to quantify like the 'coverage'
    another way would be something like ligand sasa but idk if this works
        without full protein, since other parts could shield lig in full right?
--------------------------------------------------------------------------------
okay so whole ligand gets coverage, and most contacts appear to be
favorable (remember that I am excluding fa sol here )


    so I guess next question on this thread is what contacts are MOST favorable?
'''


import os
import math
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
from pyrosetta import *
init()
from pyrosetta.rosetta.core.scoring.sasa import *

def return_residue_indices(fuzzball_lines):
    fuzzball_residue_indices=[];fuzzball_seen_resnums=[]
    starts=[];lasts=[]
    for index, line in enumerate(fuzzball_lines): #collecting start/end indices for unique res
            resnum=int(fuzzball_lines[index][22:26])
            resname=line[17:20]
            try:
                lastresnum=int(fuzzball_lines[index-1][22:26])
                lastresname=fuzzball_lines[index-1][17:20]
                if resnum!=lastresnum or resname!=lastresname:
                    start=index
                    starts.append(start)
            except:
                start=index
                starts.append(start)
            try:
                nextresname=fuzzball_lines[index+1][17:20]
                next_resnum=int(fuzzball_lines[index+1][22:26])
                if resnum!=next_resnum or resname!=nextresname:
                    last=index+1
                    lasts.append(last)
            except:
                last=len(fuzzball_lines)
                lasts.append(last)
    for index,start in enumerate(starts): #put the indices together for each res
        fuzzball_residue_indices.append((start,lasts[index]))
    fuzzball_residue_indices=list(set(fuzzball_residue_indices)) #ensure no redundant indices
    fuzzball_residue_indices=sorted(fuzzball_residue_indices, key=lambda first: first[0])
    return fuzzball_residue_indices

def displace(p1,p2):
	x = p1[0] - p2[0]
	y = p1[1] - p2[1]
	z = p1[2] - p2[2]
	return (x,y,z)
def norm(x):
    return math.sqrt(sum(i**2 for i in x))
def dist(p1,p2):
	v = displace(p1,p2)
	return norm(v)

sf = ScoreFunction()
from pyrosetta.rosetta.core.scoring import fa_atr, fa_rep, fa_sol,hbond_sc, fa_elec, hbond_bb_sc
sf.set_weight(fa_atr, 1)
sf.set_weight(fa_rep, .55)
# sf.set_weight(fa_sol, 1)
sf.set_weight(hbond_sc, 1)
sf.set_weight(fa_elec, 1)
sf.set_weight(hbond_bb_sc,1)

pdbfiles=[file for file in os.listdir(os.getcwd()) if file[-3:]=='pdb']

amino_acids=['ARG','ASN','ASP','GLU','GLN',
             'HIS','ILE','LEU','LYS','MET','PHE','SER',
             'THR','TRP','TYR','VAL']
contact_resnames=[]

lig_contact_atom_names=[]

n_contacts_each_ptn=[]

lig_sasas=[]

paramsfile=[sys.argv[1]]

first_shell_scores=[]
nfavres=[]

for file in pdbfiles:
    f=open(file,'r')
    liglines=[]
    reslines=[]
    for line in f.readlines():
        if line[0:4]=='ATOM' and line[17:20]==sys.argv[2]:
            liglines.append(line)
        elif line[0:4]=='ATOM' and line[17:20]!=sys.argv[2]:
            reslines.append(line)
    f.close()
    res_indices=return_residue_indices(reslines)
    n_contacts_this_ptn=len(res_indices)
    n_contacts_each_ptn.append(n_contacts_this_ptn)
    for a,b in res_indices:
        contact_resnames.append(reslines[a][17:20].upper())
    for atom in liglines:
        atomname=atom[11:16]
        atomcoords=( float(atom[31:39]),float(atom[39:47]),float(atom[47:54]) )
        for a,b in res_indices:
            current_residue_lines=[i for i in reslines[a:b]]
            for line in current_residue_lines:
                ptn_atom_coords=( float(line[31:39]),float(line[39:47]),float(line[47:54]) )
                d=dist(ptn_atom_coords, atomcoords)
                if d<4.1:
                    lig_contact_atom_names.append(atomname)
                    break
    p=Pose()
    generate_nonstandard_residue_set(p,paramsfile)
    pose_from_file(p, file)
    lig_sasa=pyrosetta.rosetta.core.scoring.sasa.per_res_sc_sasa(p)[len(pyrosetta.rosetta.core.scoring.sasa.per_res_sc_sasa(p))]
    ligand_resnum=p.total_residue()
    nligatoms=len(p.residue(ligand_resnum).atoms())
    lig_per_atom_sasa=lig_sasa/nligatoms #######################################
    lig_sasas.append(lig_per_atom_sasa)
    whole_site_score=sf(p)
    first_shell_scores.append(whole_site_score)
    favorable_res=0
    for i in range(1,p.total_residue()):
        contact_pose=Pose()
        ligand_pose=p.residue(ligand_resnum).clone()
        res_pose=p.residue(i).clone()
        contact_pose.append_residue_by_jump(res_pose, 1)
        contact_pose.append_residue_by_jump(ligand_pose, 1)
        # rosetta.core.pack.optimizeH(contact_pose, sf)
        residue_score=sf(contact_pose)
        if residue_score<=0:
            favorable_res+=1
    nfavres.append(favorable_res)




pdf = PdfPages('stats.pdf')

################
ofile=open('stats.txt','w')
mean_n_contact_res=np.mean(n_contacts_each_ptn)
print('lig sasas:')
print(lig_sasas)
print('scores: ')
print(first_shell_scores)
print('nfavres: ')
print(nfavres)
ofile.write('the mean number of contact res is: '+str(mean_n_contact_res)+'\n')
ofile.write('\nThe mean per atom ligand sasa is: '+str(np.mean(lig_sasas)))
ofile.write('\nThe mean score is: '+str(np.mean(first_shell_scores)))
ofile.write('\nThe mean number of favorable res is: '+str(np.mean(nfavres)))
ofile.close()

#################
unique_n_contact_list=list(set(n_contacts_each_ptn))
ncontactdict={}
for i in unique_n_contact_list:
    count=0
    for k in n_contacts_each_ptn:
        if i==k:
            count+=1
    ncontactdict[i]=count

scx,scy=list(ncontactdict.keys()),ncontactdict.values()
sortlist=[]
for i,e in enumerate(scy):
    sortlist.append((scx[i],e))
sortlist=sorted(sortlist, reverse=True, key=lambda nmem: nmem[1])
scx=[];scy=[]
for a,b in sortlist:
    scx.append(a);scy.append(b)
plt.bar(scx, scy)
plt.xticks(rotation='vertical')
plt.xlabel('contact res count')
plt.ylabel('frequency')
plt.title('distribution of number of contacts')
pdf.savefig()
plt.clf()

##################
n_contact_res=float(len(contact_resnames))
aa_frequency_dict={}
for resname in amino_acids:
    count=0
    for contact_resname in contact_resnames:
        if contact_resname==resname:
            count+=1
    aa_frequency_dict[resname]=count/n_contact_res

scx,scy=list(aa_frequency_dict.keys()),aa_frequency_dict.values()
sortlist=[]
for i,e in enumerate(scy):
    sortlist.append((scx[i],e))
sortlist=sorted(sortlist, reverse=True, key=lambda nmem: nmem[1])
scx=[];scy=[]
for a,b in sortlist:
    scx.append(a);scy.append(b)
plt.bar(scx, scy)
plt.xticks(rotation='vertical')
plt.xlabel('Residue')
plt.ylabel('Frequency')
plt.title('Amino Acid Frequencies for Contacts')
pdf.savefig()
plt.clf()

##################
unique_lig_atoms=list(set(lig_contact_atom_names))
ligatom_freq_dict={}
n_contacts_ligs=float(len(lig_contact_atom_names))
for atom in unique_lig_atoms:
    count=0
    for contact_atom in lig_contact_atom_names:
        if atom==contact_atom:
            count+=1
    ligatom_freq_dict[atom]=count/n_contacts_ligs
scx,scy=list(ligatom_freq_dict.keys()),ligatom_freq_dict.values()
sortlist=[]
for i,e in enumerate(scy):
    sortlist.append((scx[i],e))
sortlist=sorted(sortlist, reverse=True, key=lambda nmem: nmem[1])
scx=[];scy=[]
for a,b in sortlist:
    scx.append(a);scy.append(b)
plt.bar(scx, scy)
plt.xticks(rotation='vertical')
plt.xlabel('Ligand Atom')
plt.ylabel('Fraction of Contacts')
plt.title('Most Contacted Ligand Atoms')
pdf.savefig()
plt.clf()

pdf.close()
